import cog

def init_params(params, header_file, namespace, class_name, param_path):
    for param in params:
        param.path = param_path
        param.header_file = header_file
        param.namespace = namespace
        param.class_name = class_name
    return params

def get_warning_comment(class_name):
    return f'// Auto generated code. See class document of {class_name}.'

def declare_begin(module, header=True):
    class_name = module.ClassName
    namespace = module.NameSpace
    params = module.Params
    param_path = module.ParamPath
    param_file = getattr(module, 'ParamFile', module.ClassName + '.py')
    header_file = getattr(module, 'HeaderFile', module.ClassName + '.h')
    source_file = getattr(module, 'SourceFile', module.ClassName + '.cpp')
    class_doc = module.ClassDoc

    if header:
        cog.out(f'''
#include <Base/Parameter.h>
''')

    cog.out(f'''
namespace {namespace} {{
/** {class_doc}

 * The parameters are under group "{param_path}"
 *
 * This class is auto generated by {param_file}. Modify that file
 * instead of this one, if you want to add any parameter. You need
 * to install Cog Python package for code generation:
 * @code
 *     pip install cogapp
 * @endcode
 *
 * Once modified, you can regenerate the header and the source file,
 * @code
 *     python3 -m cogapp -r {header_file} {source_file}
 * @endcode
 *
 * You can add a new parameter by adding lines in {param_file}. Available
 * parameter types are 'Int, UInt, String, Bool, Float'. For example, to add
 * a new Int type parameter,
 * @code
 *     ParamInt(parameter_name, default_value, documentation, on_change=False)
 * @endcode
 *
 * If there is special handling on parameter change, pass in on_change=True.
 * And you need to provide a function implementation in {source_file} with
 * the following signature.
 * @code
 *     void {class_name}:on<parameter_name>Changed()
 * @endcode
 */
class {namespace}Export {class_name} {{
public:
    static ParameterGrp::handle getHandle();
''')

    for param in params:
        cog.out(f'''
    //@{{
    /// Accessor for parameter {param.name}''')
        if param._doc:
            cog.out(f'''
    ///''')
            for line in param._doc.split('\n'):
                cog.out(f'''
    /// {line}''')
        cog.out(f'''
    static const {param.C_Type} & get{param.name}();
    static const {param.C_Type} & default{param.name}();
    static void remove{param.name}();
    static void set{param.name}(const {param.C_Type} &v);
    static const char *doc{param.name}();''')
        if param.on_change:
            cog.out(f'''
    static void on{param.name}Changed();''')
        cog.out(f'''
    //@}}
''')


def declare_end(module):
    class_name = module.ClassName
    namespace = module.NameSpace
    warning_comment = get_warning_comment(class_name)

    cog.out(f'''
    {warning_comment}
}};
}} // namespace {namespace}
''')


def define(module, header=True):
    class_name = module.ClassName
    namespace = module.NameSpace
    params = module.Params
    param_path = module.ParamPath
    class_doc = module.ClassDoc
    warning_comment = get_warning_comment(class_name)

    if header:
        cog.out(f'''
{warning_comment}
#include <unordered_map>
#include <App/Application.h>
#include <App/DynamicProperty.h>
#include "{class_name}.h"
using namespace {namespace};
''')

    cog.out(f'''
namespace {{

{warning_comment}
class {class_name}P: public ParameterGrp::ObserverType {{
public:
    {warning_comment}
    ParameterGrp::handle handle;

    {warning_comment}
    std::unordered_map<const char *,void(*)({class_name}P*),App::CStringHasher,App::CStringHasher> funcs;
''')

    for param in params:
        cog.out(f'''
    {param.C_Type} {param.name}; {warning_comment}''')

    cog.out(f'''

    {warning_comment}
    {class_name}P() {{
        handle = App::GetApplication().GetParameterGroupByPath("{param_path}");
        handle->Attach(this);
''')

    for param in params:
        cog.out(f'''
        {param.name} = handle->Get{param.Type}("{param.name}", {param.default});
        funcs["{param.name}"] = &{class_name}P::update{param.name};''')

    cog.out(f'''
    }}

    {warning_comment}
    ~{class_name}P() {{
    }}

    {warning_comment}
    void OnChange(Base::Subject<const char*> &, const char* sReason) {{
        if(!sReason)
            return;
        auto it = funcs.find(sReason);
        if(it == funcs.end())
            return;
        it->second(this);
    }}

''')

    for param in params:
        if not param.on_change:
            cog.out(f'''
    {warning_comment}
    static void update{param.name}({class_name}P *self) {{
        self->{param.name} = self->handle->Get{param.Type}("{param.name}", {param.default});
    }}''')
        else:
            cog.out(f'''
    {warning_comment}
    static void update{param.name}({class_name}P *self) {{
        auto v = self->handle->Get{param.Type}("{param.name}", {param.default});
        if (self->{param.name} != v) {{
            self->{param.name} = v;
            {class_name}::on{param.name}Changed();
        }}
    }}''')

    cog.out(f'''
}};

{warning_comment}
{class_name}P *instance() {{
    static {class_name}P *inst = new {class_name}P;
    return inst;
}}

}} // Anonymous namespace

{warning_comment}
ParameterGrp::handle {class_name}::getHandle() {{
    return instance()->handle;
}}
''')

    for param in params:
        cog.out(f'''
{warning_comment}
const char *{class_name}::doc{param.name}() {{
    return {param.doc(class_name)};
}}

{warning_comment}
const {param.C_Type} & {class_name}::get{param.name}() {{
    return instance()->{param.name};
}}

{warning_comment}
const {param.C_Type} & {class_name}::default{param.name}() {{
    const static {param.C_Type} def = {param.default};
    return def;
}}

{warning_comment}
void {class_name}::set{param.name}(const {param.C_Type} &v) {{
    instance()->handle->Set{param.Type}("{param.name}",v);
    instance()->{param.name} = v;
}}

{warning_comment}
void {class_name}::remove{param.name}() {{
    instance()->handle->Remove{param.Type}("{param.name}");
}}
''')

def widgets_declare(param_set):
    param_group = param_set.ParamGroup
    class_name = param_set.ClassName
    warning_comment = get_warning_comment(class_name)

    for name,_,params in param_group:
        cog.out(f'''
    {warning_comment}
    QGroupBox * group{name} = nullptr;''')
        for param in params:
            if not isinstance(param, ParamBool):
                cog.out(f'''
    QLabel *label{param.name} = nullptr;''')
            cog.out(f'''
    {param.WidgetType} *{param.WidgetPrefix}{param.name} = nullptr;''')

def widgets_init(param_set, parent='this'):
    class_name = param_set.ClassName
    param_group = param_set.ParamGroup
    warning_comment = get_warning_comment(class_name)

    cog.out(f'''
    auto layout = new QVBoxLayout({parent});''')
    for name, title, params in param_group:
        row = 0
        cog.out(f'''
    {warning_comment}
    group{name} = new QGroupBox({parent});
    auto layout{name} = new QGridLayout(group{name});
    layout->addWidget(group{name});''')

        for param in params:
            widget_name = param.WidgetPrefix + param.name
            cog.out(f'''
    {warning_comment}
    {widget_name} = new {param.WidgetType}({parent});''')
            if not isinstance(param, ParamBool):
                cog.out(f'''
    label{param.name} = new QLabel({parent});
    layout{name}->addWidget(label{param.name}, {row}, 0);
    layout{name}->addWidget({widget_name}, {row}, 1);''')
            else:
                cog.out(f'''
    layout{name}->addWidget({widget_name}, {row}, 0);''')
            cog.out(f'''
    {widget_name}->{param.WidgetSetter}({param.default});
    {widget_name}->setEntryName("{param.name}");''')
            prefix = 'User parameter:BaseApp/Preferences/'
            if param.path.startswith(prefix):
                cog.out(f'''
    {widget_name}->setParamGrpPath("{param.path[len(prefix):]}");''')
            else:
                cog.out(f'''
    {widget_name}->setParamGrpPath("{param.path}");''')
            row += 1

    cog.out('''
    layout->addItem(new QSpacerItem(40, 20, QSizePolicy::Fixed, QSizePolicy::Expanding));
    retranslateUi();''')

def widgets_restore(param_set):
    param_group = param_set.ParamGroup

    for _,_,params in param_group:
        for param in params:
            cog.out(f'''
    {param.WidgetPrefix}{param.name}->onRestore();''')

def widgets_save(param_set):
    param_group = param_set.ParamGroup

    for _,_,params in param_group:
        for param in params:
            cog.out(f'''
    {param.WidgetPrefix}{param.name}->onSave();''')

def preference_dialog_declare_begin(param_set, header=True):
    namespace = param_set.NameSpace
    class_name = param_set.ClassName
    dialog_namespace = getattr(param_set, 'DialogNameSpace', 'Dialog')
    param_group = param_set.ParamGroup
    param_file = getattr(param_set, 'ParamFile', class_name + '.py')
    header_file = getattr(param_set, 'HeaderFile', class_name + '.h')
    source_file = getattr(param_set, 'SourceFile', class_name + '.cpp')
    class_doc = param_set.ClassDoc

    if header:
        cog.out(f'''
#include <Gui/PropertyPage.h>
#include <Gui/PrefWidgets.h>''')

    cog.out(f'''

class QLabel;

namespace {namespace} {{
namespace {dialog_namespace} {{
/** {class_doc}

 * This class is auto generated by {param_file}. Modify that file
 * instead of this one, if you want to make any change. You need
 * to install Cog Python package for code generation:
 * @code
 *     pip install cogapp
 * @endcode
 *
 * Once modified, you can regenerate the header and the source file,
 * @code
 *     python3 -m cogapp -r {header_file} {source_file}
 * @endcode
 */
class {class_name} : public PreferencePage
{{
    Q_OBJECT

public:
    {class_name}( QWidget* parent = 0 );
    ~{class_name}();

    void saveSettings();
    void loadSettings();
    void retranslateUi();

protected:
    void changeEvent(QEvent *e);

private:
''')
    widgets_declare(param_set)


def preference_dialog_declare_end(param_set):
    namespace = param_set.NameSpace
    dialog_namespace = getattr(param_set, 'DialogNameSpace', 'Dialog')

    cog.out(f'''
}};
}} // namespace {{dialog_namespace}}
}} // namespace {{namespace}}
''')

def preference_dialog_declare(param_set, header=True):
    preference_dialog_declare_begin(param_set, header)
    preference_dialog_declare_end(param_set)

def preference_dialog_define(param_set, header=True):
    param_group = param_set.ParamGroup
    class_name = param_set.ClassName
    dialog_namespace = getattr(param_set, 'DialogNameSpace', 'Dialog')
    namespace = f'{param_set.NameSpace}::{dialog_namespace}'
    param_file = getattr(param_set, 'ParamFile', class_name + '.py')
    header_file = getattr(param_set, 'HeaderFile', class_name + '.h')
    source_file = getattr(param_set, 'SourceFile', class_name + '.cpp')
    warning_comment = get_warning_comment(class_name)
    headers = set()

    if header:
        cog.out(f'''
#ifndef _PreComp_
#   include <QApplication>
#   include <QLabel>
#   include <QGroupBox>
#   include <QGridLayout>
#   include <QVBoxLayout>
#endif
#include <Gui/PrefWidgets.h>
#include "{header_file}"''')
        for _,_,params in param_group:
            for param in params:
                if not param.header_file in headers:
                    headers.add(param.header_file)
                    cog.out(f'''
#include <{param.header_file}>''')

    cog.out(f'''

using namespace {namespace};

/* TRANSLATOR {namespace}::{class_name} */

{class_name}::{class_name}(QWidget* parent)
    : PreferencePage( parent )
{{
''')
    widgets_init(param_set)

    cog.out(f'''
}}

{class_name}::~{class_name}()
{{
}}


void {class_name}::saveSettings()
{{
    {warning_comment}''')
    widgets_save(param_set)
    cog.out(f'''
}}

void {class_name}::loadSettings()
{{
    {warning_comment}''')
    widgets_restore(param_set)
    cog.out(f'''
}}

void {class_name}::retranslateUi()
{{
    {warning_comment}
    setWindowTitle(QObject::tr("{param_set.Title}"));''')
    for name, title, params in param_group:
        cog.out(f'''
    group{name}->setTitle(QObject::tr("{title}"));''')
        for param in params:
            widget_name = param.WidgetPrefix + param.name
            if not isinstance(param, ParamBool):
                cog.out(f'''
    label{param.name}->setText(QObject::tr("{param.title}"));
    label{param.name}->setToolTip(QApplication::translate(
                                    "{param.class_name}",
                                    {param.namespace}::{param.class_name}::doc{param.name}()));''')
            else:
                cog.out(f'''
    {widget_name}->setText(QObject::tr("{param.title}"));
    {widget_name}->setToolTip(QApplication::translate(
                                    "{param.class_name}",
                                    {param.namespace}::{param.class_name}::doc{param.name}()));''')
    cog.out(f'''
}}

void {class_name}::changeEvent(QEvent *e)
{{
    {warning_comment}
    if (e->type() == QEvent::LanguageChange) {{
        retranslateUi();
    }}
    else {{
        QWidget::changeEvent(e);
    }}
}}

#include "moc_{class_name}.cpp"
''')

class Param:
    def __init__(self, name, default, doc='', title='', on_change=False):
        self.name = name
        self.title = title if title else name
        self._default = default
        self._doc = doc
        self.on_change = on_change

    @property
    def default(self):
        return self._default

    def doc(self, class_name):
        if not self._doc:
            return '""'

        def quote(txt):
            lines = [ '"' + l.replace('"', '\"').replace('\\', '\\\\') for l in txt.split('\n')]
            return '\\n"\n'.join(lines) + '"'

        return f'''QT_TRANSLATE_NOOP("{class_name}",
{quote(self._doc)})'''

    @property
    def widget_name(self):
        return f'{self.WidgetPrefix}{self.name}'

class ParamBool(Param):
    Type = 'Bool'
    C_Type = 'bool'
    WidgetType = 'Gui::PrefCheckBox'
    WidgetPrefix = 'checkBox'
    WidgetSetter = 'setChecked'

    @property
    def default(self):
        if isinstance(self._default, str):
            return self._default
        return 'true' if self._default else 'false'

class ParamFloat(Param):
    Type = 'Float'
    C_Type = 'double'
    WidgetType = 'Gui::PrefDoubleSpinBox'
    WidgetPrefix = 'spinBox'
    WidgetSetter = 'setValue'

class ParamString(Param):
    Type = 'ASCII'
    C_Type = 'std::string'
    WidgetType = 'Gui::PrefLineEdit'
    WidgetPrefix = 'edit'
    WidgetSetter = 'setText'

    @property
    def default(self):
        return f'"{self._default}"'

class ParamInt(Param):
    Type = 'Int'
    C_Type = 'long'
    WidgetType = 'Gui::PrefSpinBox'
    WidgetPrefix = 'spinBox'
    WidgetSetter = 'setValue'

class ParamUInt(Param):
    Type = 'Unsigned'
    C_Type = 'unsigned long'
    WidgetType = 'Gui::PrefSpinBox'
    WidgetPrefix = 'spinBox'
    WidgetSetter = 'setValue'

